from fastapi import APIRouter, HTTPException
from fastapi.responses import StreamingResponse
import json
import asyncio
from ..models import QueryRequest, RepoStatus
from .repos import repos_db

router = APIRouter(prefix="/query", tags=["query"])


@router.post("/")
async def query_repository(query: QueryRequest):
    """
    Preguntar algo sobre el repo. Cuerpo: { repo_id, question }. 
    Respuesta en stream (SSE/WebSocket).
    """
    # Check if repository exists
    if query.repo_id not in repos_db:
        raise HTTPException(status_code=404, detail="Repository not found")
    
    repo_data = repos_db[query.repo_id]
    if repo_data["status"] != RepoStatus.READY:
        raise HTTPException(
            status_code=400, 
            detail=f"Repository not ready. Current status: {repo_data['status']}"
        )
    
    # Return streaming response (SSE format)
    return StreamingResponse(
        generate_answer_stream(query.repo_id, query.question),
        media_type="text/plain"
    )


async def generate_answer_stream(repo_id: str, question: str):
    """
    Generate streaming answer for the question about the repository
    """
    # Mock streaming response (in production, integrate with LLM/RAG system)
    response_parts = [
        f"Analyzing repository {repo_id}...\n",
        f"Processing question: {question}\n",
        "Searching through code embeddings...\n",
        "Found relevant code sections...\n",
        "Generating response...\n",
        f"Answer: Based on the repository analysis, here's what I found regarding '{question}': ",
        "This is a mock response. In production, this would be generated by analyzing ",
        "the repository's code, documentation, and embeddings to provide accurate answers ",
        "about the codebase structure, functionality, and implementation details.\n",
        "Stream complete.\n"
    ]
    
    for part in response_parts:
        yield f"data: {json.dumps({'content': part, 'repo_id': repo_id})}\n\n"
        await asyncio.sleep(0.5)  # Simulate processing delay
    
    # Send end-of-stream marker
    yield f"data: {json.dumps({'content': '[DONE]', 'repo_id': repo_id})}\n\n"
